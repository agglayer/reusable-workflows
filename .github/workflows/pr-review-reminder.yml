name: PR Review Reminder

on:
  workflow_call:
    inputs:
      min_days_old:
        description: "Minimum number of days a PR must be ready for review (not draft)"
        required: false
        type: number
        default: 2
      dry_run:
        description: "Run without sending Slack notification (for testing)"
        required: false
        type: boolean
        default: false
      repository:
        description: "Repository to check (owner/repo format, defaults to current repo)"
        required: false
        type: string
        default: ""
      include_drafts:
        description: "Include draft PRs in the check"
        required: false
        type: boolean
        default: false

jobs:
  pr-review-reminder:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check PRs and send Slack notification
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TEAM_READ_GH_TOKEN: ${{ secrets.TEAM_READ_GH_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          MIN_DAYS_OLD: ${{ fromJSON(inputs.min_days_old) }}
          DRY_RUN: ${{ inputs.dry_run }}
          INCLUDE_DRAFTS: ${{ inputs.include_drafts }}
        run: |
          # Get repository info
          if [ -n "${{ inputs.repository }}" ]; then
            IFS='/' read -r REPO_OWNER REPO_NAME <<< "${{ inputs.repository }}"
          else
            REPO_OWNER="${{ github.repository_owner }}"
            REPO_NAME="${{ github.event.repository.name }}"
          fi

          echo "üîç Checking PRs for $REPO_OWNER/$REPO_NAME"
          echo "üìÖ Minimum ready time: $MIN_DAYS_OLD days"
          echo "üß™ Dry run mode: $DRY_RUN"
          echo "üìù Include drafts: $INCLUDE_DRAFTS"

          # Validate GitHub token
          if [ -z "$GITHUB_TOKEN" ]; then
            echo "‚ùå Error: GITHUB_TOKEN is not set"
            exit 1
          fi

          # Test GitHub token validity using repository endpoint
          echo "üîê Validating GitHub token..."

          # Use repository endpoint which works with GITHUB_TOKEN
          REPO_ENDPOINT="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}"

          TOKEN_TEST=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "User-Agent: PR-Review-Reminder/1.0" \
            -w "%{http_code}" \
            "$REPO_ENDPOINT")

          HTTP_CODE="${TOKEN_TEST: -3}"
          TOKEN_RESPONSE="${TOKEN_TEST%???}"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå GitHub token validation failed (HTTP $HTTP_CODE)"
            echo "Token response: $TOKEN_RESPONSE"
            echo "üìù Possible issues:"
            echo "  - Token is expired or invalid"
            echo "  - Token doesn't have required permissions for repository access"
            echo "  - Rate limit exceeded"
            echo "  - Network connectivity issues"
            exit 1
          fi

          REPO_NAME_RESPONSE=$(echo "$TOKEN_RESPONSE" | jq -r '.name // "unknown"')
          REPO_OWNER_RESPONSE=$(echo "$TOKEN_RESPONSE" | jq -r '.owner.login // "unknown"')
          echo "‚úÖ GitHub token valid - accessed repository: $REPO_OWNER_RESPONSE/$REPO_NAME_RESPONSE"

          # Validate inputs
          if [ "$DRY_RUN" = "false" ] && [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "‚ùå Error: SLACK_WEBHOOK_URL is required when dry_run is false"
            exit 1
          fi

          # GitHub API headers
          API_HEADERS=(
            -H "Authorization: token $GITHUB_TOKEN"
            -H "Accept: application/vnd.github.v3+json"
            -H "User-Agent: PR-Review-Reminder/1.0"
          )

          # GitHub API headers
          MEMBERSHIP_API_HEADERS=(
            -H "Authorization: token $TEAM_READ_GH_TOKEN"
            -H "Accept: application/vnd.github.v3+json"
            -H "User-Agent: PR-Review-Reminder/1.0"
          )
          # Get codeowners from CODEOWNERS file
          CODEOWNERS=""
          if [ -f ".github/CODEOWNERS" ]; then
            CODEOWNERS=$(grep -v '^#' .github/CODEOWNERS | grep -v '^$' | awk '{for(i=2;i<=NF;i++) print $i}' | sed 's/@//g' | tr '\n' ' ')
            echo "üë• Codeowners: $CODEOWNERS"
          else
            echo "‚ö†Ô∏è No CODEOWNERS file found, trying to fetch from API..."
            # Try to get CODEOWNERS from API
            CODEOWNERS_RESPONSE=$(curl -s "${API_HEADERS[@]}" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/contents/.github/CODEOWNERS")

            if echo "$CODEOWNERS_RESPONSE" | jq -e '.content' > /dev/null 2>&1; then
              CODEOWNERS_CONTENT=$(echo "$CODEOWNERS_RESPONSE" | jq -r '.content' | base64 -d)
              CODEOWNERS=$(echo "$CODEOWNERS_CONTENT" | grep -v '^#' | grep -v '^$' | awk '{for(i=2;i<=NF;i++) print $i}' | sed 's/@//g' | tr '\n' ' ')
              echo "üë• Codeowners (from API): $CODEOWNERS"
            else
              echo "‚ö†Ô∏è No CODEOWNERS file found in repository"
            fi
          fi

          # Get all open PRs using GitHub API
          echo "üìä Fetching open PRs..."
          PR_RESPONSE=$(curl -s "${API_HEADERS[@]}" \
            -w "%{http_code}" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/pulls?state=open&per_page=100")

          # Extract HTTP status code and response body
          PR_HTTP_CODE="${PR_RESPONSE: -3}"
          PR_BODY="${PR_RESPONSE%???}"

          # Save response body to file
          echo "$PR_BODY" > prs.json

          # Check if API call was successful
          if [ "$PR_HTTP_CODE" != "200" ]; then
            echo "‚ùå Failed to fetch PRs from GitHub API (HTTP $PR_HTTP_CODE)"
            echo "API Response: $PR_BODY"
            echo "üìù Possible issues:"
            echo "  - Repository not found or no access: $REPO_OWNER/$REPO_NAME"
            echo "  - Token doesn't have 'pull-requests: read' permission"
            echo "  - Repository is private and token lacks access"
            echo "  - Rate limit exceeded"
            exit 1
          fi

          # Check for API errors in response body
          if echo "$PR_BODY" | jq -e '.message' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$PR_BODY" | jq -r '.message')
            echo "‚ùå GitHub API Error: $ERROR_MSG"
            echo "üìù Full response: $PR_BODY"
            exit 1
          fi

          # Validate that we got an array
          if ! echo "$PR_BODY" | jq -e 'type == "array"' > /dev/null 2>&1; then
            echo "‚ùå Unexpected API response format (expected array)"
            echo "Response: $PR_BODY"
            exit 1
          fi

          TOTAL_PRS=$(jq length prs.json)
          echo "üìä Found $TOTAL_PRS open PRs"

          # Initialize arrays for filtered PRs
          FILTERED_PRS="[]"

          # Calculate date threshold
          DATE_THRESHOLD=$(date -d "$MIN_DAYS_OLD days ago" --iso-8601=seconds)

          # Function to check team membership
          check_team_membership() {
            local author=$1
            local team_name=$2

            # Handle team format like "org/team-name"
            if [[ "$team_name" == *"/"* ]]; then
              local org_team=(${team_name//\// })
              local org=${org_team[0]}
              local team=${org_team[1]}
            else
              local org=$REPO_OWNER
              local team=$team_name
            fi

            # Check team membership via API
            local membership_response=$(curl -s "${MEMBERSHIP_API_HEADERS[@]}" \
              -w "%{http_code}" \
              "https://api.github.com/orgs/$org/teams/$team/memberships/$author" 2>/dev/null)

            local membership_http_code="${membership_response: -3}"
            local membership_body="${membership_response%???}"

            if [ "$membership_http_code" = "200" ]; then
              if echo "$membership_body" | jq -e '.state' > /dev/null 2>&1; then
                local state=$(echo "$membership_body" | jq -r '.state')
                if [ "$state" = "active" ]; then
                  return 0  # Author is team member
                fi
              fi
            elif [ "$membership_http_code" = "404" ]; then
              # 404 means user is not a member (this is expected)
              return 1
            else
              # Other errors (403 forbidden, etc.)
              echo "   ‚ö†Ô∏è  Team membership check failed for $team (HTTP $membership_http_code)"
            fi

            return 1  # Author is not team member
          }

          # Function to get PR reviews
          get_pr_reviews() {
            local pr_number=$1
            local reviews_response=$(curl -s "${API_HEADERS[@]}" \
              -w "%{http_code}" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/pulls/$pr_number/reviews")

            local reviews_http_code="${reviews_response: -3}"
            local reviews_body="${reviews_response%???}"

            if [ "$reviews_http_code" = "200" ]; then
              echo "$reviews_body"
            else
              echo "[]"  # Return empty array on error
            fi
          }

          # Function to get PR requested reviewers
          get_pr_requested_reviewers() {
            local pr_number=$1
            local reviewers_response=$(curl -s "${API_HEADERS[@]}" \
              -w "%{http_code}" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/pulls/$pr_number/requested_reviewers")

            local reviewers_http_code="${reviewers_response: -3}"
            local reviewers_body="${reviewers_response%???}"

            if [ "$reviewers_http_code" = "200" ]; then
              echo "$reviewers_body"
            else
              echo '{"users":[],"teams":[]}'  # Return empty structure on error
            fi
          }

          # Function to get latest review date
          get_latest_review_date() {
            local pr_number=$1
            local reviews=$(get_pr_reviews "$pr_number")

            echo "   üîç Getting latest review date for PR #$pr_number" >&2

            local review_count=$(echo "$reviews" | jq length)
            echo "   üìä Found $review_count reviews" >&2

            if [ "$review_count" -gt 0 ]; then
              # Get the most recent review date
              local latest_date=$(echo "$reviews" | jq -r '[.[].submitted_at] | sort | last')
              if [ "$latest_date" != "null" ] && [ -n "$latest_date" ]; then
                echo "   üìÖ Latest review date: $latest_date" >&2
                echo "$latest_date"
                return
              fi
            fi

            # No reviews found
            echo "   üìÖ No reviews found" >&2
            echo ""
          }

          # Function to get when PR became ready for review
          get_pr_ready_date() {
            local pr_number=$1
            local pr_created=$2
            local pr_draft=$3

            echo "   üîç Calculating ready date for PR #$pr_number (current draft: $pr_draft)" >&2

            # Always get timeline to handle complex ready/draft/ready transitions
            local timeline_response=$(curl -s "${API_HEADERS[@]}" \
              -w "%{http_code}" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/issues/$pr_number/timeline")

            local timeline_http_code="${timeline_response: -3}"
            local timeline_body="${timeline_response%???}"

            if [ "$timeline_http_code" = "200" ]; then
              # Get all ready_for_review and convert_to_draft events with timestamps
              local events=$(echo "$timeline_body" | jq -r '.[] | select(.event == "ready_for_review" or .event == "convert_to_draft") | "\(.created_at) \(.event)"' | sort)

              if [ -n "$events" ]; then
                echo "   üìä Found timeline events:" >&2
                echo "$events" | while read -r event; do
                  echo "      $event" >&2
                done
              else
                echo "   üìä No ready/draft timeline events found" >&2
              fi

              if [ -n "$events" ]; then
                # Find the last ready_for_review event that wasn't followed by convert_to_draft
                local last_ready_date=""
                local current_state="ready"  # Assume created ready unless we see convert_to_draft first

                # Check if PR was created as draft by looking for convert_to_draft before any ready_for_review
                local first_event=$(echo "$events" | head -1 | awk '{print $2}')
                if [ "$first_event" = "convert_to_draft" ]; then
                  current_state="draft"
                fi

                # Process events chronologically
                while IFS= read -r event_line; do
                  if [ -n "$event_line" ]; then
                    local event_date=$(echo "$event_line" | awk '{print $1}')
                    local event_type=$(echo "$event_line" | awk '{print $2}')

                    if [ "$event_type" = "ready_for_review" ]; then
                      last_ready_date="$event_date"
                      current_state="ready"
                    elif [ "$event_type" = "convert_to_draft" ]; then
                      current_state="draft"
                    fi
                  fi
                done <<< "$events"

                # If we found a ready event and current state matches PR status, use it
                if [ -n "$last_ready_date" ]; then
                  echo "   üìÖ Last ready date from timeline: $last_ready_date (current timeline state: $current_state)" >&2
                  if [ "$pr_draft" = "false" ] && [ "$current_state" = "ready" ]; then
                    echo "   ‚úÖ Using timeline ready date: $last_ready_date" >&2
                    echo "$last_ready_date"
                    return
                  elif [ "$pr_draft" = "true" ] && [ "$current_state" = "draft" ] && [ -n "$last_ready_date" ]; then
                    # PR is currently draft but was ready before - use last ready date
                    echo "   ‚úÖ Using last ready date (PR now draft): $last_ready_date" >&2
                    echo "$last_ready_date"
                    return
                  fi
                fi
              fi

              # No timeline events found, check if PR was created ready
              if [ "$pr_draft" = "false" ]; then
                echo "   ‚úÖ Using creation date (created ready): $pr_created" >&2
                echo "$pr_created"
                return
              fi
            fi

            # Fallback: if PR is currently draft and no ready events found, it was never ready
            if [ "$pr_draft" = "true" ]; then
              echo "   ‚ö†Ô∏è  Using creation date (draft, never ready): $pr_created" >&2
              echo "$pr_created"  # Use creation date but this PR should probably be filtered out
            else
              # PR is currently ready but no timeline events - created ready
              echo "   ‚úÖ Using creation date (fallback, ready): $pr_created" >&2
              echo "$pr_created"
            fi
          }

          # Process each PR
          for i in $(seq 0 $((TOTAL_PRS - 1))); do
            PR=$(jq ".[$i]" prs.json)

            PR_NUMBER=$(echo "$PR" | jq -r '.number')
            PR_TITLE=$(echo "$PR" | jq -r '.title')
            PR_AUTHOR=$(echo "$PR" | jq -r '.user.login')
            PR_CREATED=$(echo "$PR" | jq -r '.created_at')
            PR_URL=$(echo "$PR" | jq -r '.html_url')
            PR_DRAFT=$(echo "$PR" | jq -r '.draft')

            # Get when PR became ready for review
            PR_READY_DATE=$(get_pr_ready_date "$PR_NUMBER" "$PR_CREATED" "$PR_DRAFT")

            # Get latest review date
            PR_LATEST_REVIEW=$(get_latest_review_date "$PR_NUMBER")

            echo ""
            echo "üîç Checking PR #$PR_NUMBER: $PR_TITLE"
            echo "   Author: $PR_AUTHOR"

            # Skip draft PRs unless explicitly included
            if [ "$PR_DRAFT" = "true" ] && [ "$INCLUDE_DRAFTS" = "false" ]; then
              echo "   ‚ùå PR is a draft - skipping"
              continue
            fi

            # Check if author is in codeowners
            AUTHOR_IS_CODEOWNER=false
            if [[ " $CODEOWNERS " == *" $PR_AUTHOR "* ]]; then
              AUTHOR_IS_CODEOWNER=true
            else
              # Check if author is member of any team in codeowners
              for owner in $CODEOWNERS; do
                if [[ "$owner" == *"/"* ]] || [[ "$owner" == *"-developers"* ]] || [[ "$owner" == *"-team"* ]] || [[ "$owner" == *"-maintainers"* ]]; then
                  if check_team_membership "$PR_AUTHOR" "$owner"; then
                    AUTHOR_IS_CODEOWNER=true
                    break
                  fi
                fi
              done
            fi

            if [ "$AUTHOR_IS_CODEOWNER" = "false" ]; then
              echo "   ‚ùå Author is not a codeowner or team member"
              continue
            fi

            echo "   ‚úÖ Author is a codeowner or team member"

            # Check if PR has been ready for review longer than threshold
            if [[ "$PR_READY_DATE" > "$DATE_THRESHOLD" ]]; then
              echo "   ‚ùå PR has been ready for less than $MIN_DAYS_OLD days"
              continue
            fi

            echo "   ‚úÖ PR has been ready for review for $MIN_DAYS_OLD+ days"

            # Check if PR is waiting for review
            REVIEWS=$(get_pr_reviews "$PR_NUMBER")
            REVIEW_REQUESTS=$(get_pr_requested_reviewers "$PR_NUMBER")

            WAITING_FOR_REVIEW=false

            # If there are pending review requests, it's waiting
            PENDING_REVIEWERS=$(echo "$REVIEW_REQUESTS" | jq '.users | length')
            PENDING_TEAMS=$(echo "$REVIEW_REQUESTS" | jq '.teams | length')

            if [ "$PENDING_REVIEWERS" -gt 0 ] || [ "$PENDING_TEAMS" -gt 0 ]; then
              WAITING_FOR_REVIEW=true
            # If no reviews at all, it's waiting
            elif [ "$(echo "$REVIEWS" | jq length)" -eq 0 ]; then
              WAITING_FOR_REVIEW=true
            else
              # Check if any reviews are approvals
              APPROVALS=$(echo "$REVIEWS" | jq '[.[] | select(.state == "APPROVED")] | length')
              if [ "$APPROVALS" -eq 0 ]; then
                WAITING_FOR_REVIEW=true
              fi
            fi

            if [ "$WAITING_FOR_REVIEW" = "false" ]; then
              echo "   ‚ùå PR is not waiting for review"
              continue
            fi

            echo "   ‚úÖ PR is waiting for review"
            echo "   üéØ PR matches all criteria - adding to list"

            # Calculate days ready
            READY_TIMESTAMP=$(date -d "$PR_READY_DATE" +%s)
            CURRENT_TIMESTAMP=$(date +%s)
            DAYS_READY=$(( (CURRENT_TIMESTAMP - READY_TIMESTAMP) / 86400 ))

            # Also calculate total days since creation for display
            CREATED_TIMESTAMP=$(date -d "$PR_CREATED" +%s)
            DAYS_OLD=$(( (CURRENT_TIMESTAMP - CREATED_TIMESTAMP) / 86400 ))

            # Get requested reviewers list
            REQUESTED_USERS=$(echo "$REVIEW_REQUESTS" | jq -r '.users[].login' | tr '\n' ',' | sed 's/,$//')
            REQUESTED_TEAMS=$(echo "$REVIEW_REQUESTS" | jq -r '.teams[].name' | tr '\n' ',' | sed 's/,$//')

            REQUESTED_REVIEWERS=""
            if [ -n "$REQUESTED_USERS" ]; then
              REQUESTED_REVIEWERS="$REQUESTED_USERS"
            fi
            if [ -n "$REQUESTED_TEAMS" ]; then
              if [ -n "$REQUESTED_REVIEWERS" ]; then
                REQUESTED_REVIEWERS="$REQUESTED_REVIEWERS, $REQUESTED_TEAMS"
              else
                REQUESTED_REVIEWERS="$REQUESTED_TEAMS"
              fi
            fi

            # Add to filtered list
            PR_INFO=$(jq -n \
              --arg number "$PR_NUMBER" \
              --arg title "$PR_TITLE" \
              --arg author "$PR_AUTHOR" \
              --arg url "$PR_URL" \
              --arg days "$DAYS_OLD" \
              --arg days_ready "$DAYS_READY" \
              --arg reviewers "$REQUESTED_REVIEWERS" \
              --arg draft "$PR_DRAFT" \
              --arg latest_review "$PR_LATEST_REVIEW" \
              '{number: $number, title: $title, author: $author, url: $url, daysOld: $days, daysReady: $days_ready, requestedReviewers: $reviewers, isDraft: ($draft == "true"), latestReview: $latest_review}')

            FILTERED_PRS=$(echo "$FILTERED_PRS" | jq ". + [$PR_INFO]")
          done

          # Count filtered PRs
          FILTERED_COUNT=$(echo "$FILTERED_PRS" | jq length)
          echo ""
          echo "üìã Final result: $FILTERED_COUNT PRs match criteria"

          # Output results for other jobs/steps
          echo "filtered_prs_count=$FILTERED_COUNT" >> $GITHUB_OUTPUT
          echo "filtered_prs<<EOF" >> $GITHUB_OUTPUT
          echo "$FILTERED_PRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Prepare Slack message
          if [ "$FILTERED_COUNT" -eq 0 ]; then
            echo "‚úÖ No PRs need attention - skipping Slack notification"
            SLACK_MESSAGE=""
          else
            # Build header and PR list with divider
            HEADER_TEXT=":bloc_notes: PR Review Reminder for $REPO_OWNER/$REPO_NAME\nFound $FILTERED_COUNT PR(s) that need attention:"

            PR_LIST_TEXT=""
            for i in $(seq 0 $((FILTERED_COUNT - 1))); do
              PR=$(echo "$FILTERED_PRS" | jq ".[$i]")

              PR_TITLE=$(echo "$PR" | jq -r '.title')
              PR_URL=$(echo "$PR" | jq -r '.url')
              PR_DAYS_READY=$(echo "$PR" | jq -r '.daysReady')
              PR_REVIEWERS=$(echo "$PR" | jq -r '.requestedReviewers')
              PR_DRAFT=$(echo "$PR" | jq -r '.isDraft')
              PR_LATEST_REVIEW=$(echo "$PR" | jq -r '.latestReview')

              # Alternate between ‚Ä¢ and * for bullets
              if [ $((i % 2)) -eq 0 ]; then
                BULLET="‚Ä¢"
              else
                BULLET="*"
              fi

              REVIEWER_INFO=""
              if [ -n "$PR_REVIEWERS" ] && [ "$PR_REVIEWERS" != "" ] && [ "$PR_REVIEWERS" != "null" ]; then
                REVIEWER_INFO=" | üë• Waiting for: $PR_REVIEWERS"
              fi

              LATEST_REVIEW_INFO=""
              if [ -n "$PR_LATEST_REVIEW" ] && [ "$PR_LATEST_REVIEW" != "" ] && [ "$PR_LATEST_REVIEW" != "null" ]; then
                # Calculate days since last review
                REVIEW_TIMESTAMP=$(date -d "$PR_LATEST_REVIEW" +%s)
                CURRENT_TIMESTAMP=$(date +%s)
                DAYS_SINCE_REVIEW=$(( (CURRENT_TIMESTAMP - REVIEW_TIMESTAMP) / 86400 ))
                LATEST_REVIEW_INFO=" | üìù Last review ${DAYS_SINCE_REVIEW}d ago"
              else
                LATEST_REVIEW_INFO=" | üìù Last review Never"
              fi

              # Build single line: ‚Ä¢ <URL|Title> | ‚è±Ô∏è ready Xd ago | üìù Last review | üë• Waiting for: reviewers
              PR_LINE="$BULLET <$PR_URL|$PR_TITLE> | ‚è±Ô∏è ready ${PR_DAYS_READY}d ago${LATEST_REVIEW_INFO}${REVIEWER_INFO}\n"
              PR_LIST_TEXT="${PR_LIST_TEXT}${PR_LINE}"
            done

            SLACK_MESSAGE=$(jq -n \
              --arg text "PR Review Reminder - $FILTERED_COUNT PRs need attention" \
              --arg header_text "$HEADER_TEXT" \
              --arg pr_text "$PR_LIST_TEXT" \
              '{
                text: $text,
                blocks: [
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": $header_text
                    }
                  },
                  {"type": "divider"},
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": $pr_text
                    }
                  }
                ]
              }')
          fi

          # Send Slack notification or show dry run message
          if [ -n "$SLACK_MESSAGE" ]; then
            if [ "$DRY_RUN" = "true" ]; then
              echo "üß™ DRY RUN MODE - Slack message that would be sent:"
              echo "$SLACK_MESSAGE" | jq .
              echo "‚úÖ Dry run completed successfully"
            else
              echo "üì§ Sending Slack notification..."
              RESPONSE=$(curl -s -w "%{http_code}" -X POST "$SLACK_WEBHOOK_URL" \
                -H "Content-Type: application/json" \
                -d "$SLACK_MESSAGE")

              HTTP_CODE="${RESPONSE: -3}"
              RESPONSE_BODY="${RESPONSE%???}"

              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ Slack notification sent successfully"
              else
                echo "‚ùå Failed to send Slack notification (HTTP $HTTP_CODE)"
                echo "Response: $RESPONSE_BODY"
                exit 1
              fi
            fi
          else
            echo "‚ÑπÔ∏è No message to send"
          fi

          # Clean up
          rm -f prs.json
